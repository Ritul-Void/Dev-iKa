{
"quiz": [
    {
        "category": "JavaScript Foundations",
        "questions": [
          {
            "question": "What will be the output of the following code?\n\n```js\nfunction foo() {\n  console.log(a);\n  var a = 10;\n}\nfoo();\n```",
            "options": [
              "10",
              "undefined",
              "ReferenceError",
              "TypeError"
            ],
            "answer": 1
          },
          {
            "question": "Which of the following statements about closures is TRUE?",
            "options": [
              "Closures only exist inside arrow functions.",
              "A closure allows a function to remember the variables from its lexical scope even when it is executed outside that scope.",
              "Closures cannot access variables from outer functions once execution has moved forward.",
              "Closures are only available when using ES6+ syntax."
            ],
            "answer": 1
          },
          {
            "question": "Consider the following code. What will be logged?\n\n```js\nlet count = 0;\nfunction increment() {\n  return function() {\n    count++;\n    console.log(count);\n  };\n}\nconst inc = increment();\ninc();\ninc();\n```",
            "options": [
              "1, 2",
              "0, 1",
              "NaN, NaN",
              "ReferenceError"
            ],
            "answer": 0
          },
          {
            "question": "How does JavaScript handle prototype inheritance?",
            "options": [
              "Every object in JavaScript has a prototype, except the base object.",
              "Objects directly inherit from their parent objects, not from a prototype chain.",
              "JavaScript uses a prototypal inheritance model where objects inherit properties and methods from their prototype chain.",
              "Only ES6 classes support prototype inheritance."
            ],
            "answer": 2
          },
          {
            "question": "What will be logged in the following case?\n\n```js\nconsole.log(typeof null);\n```",
            "options": [
              "\"null\"",
              "\"undefined\"",
              "\"object\"",
              "\"NaN\""
            ],
            "answer": 2
          },
          {
            "question": "What is the result of the following code?\n\n```js\nconsole.log([] + {});\n```",
            "options": [
              "\"[object Object]\"",
              "{}",
              "NaN",
              "undefined"
            ],
            "answer": 0
          },
          {
            "question": "Which of the following is NOT a difference between `let`, `const`, and `var`?",
            "options": [
              "`var` is function-scoped while `let` and `const` are block-scoped.",
              "`const` variables cannot be reassigned while `let` and `var` can.",
              "`var` is hoisted while `let` and `const` are not hoisted.",
              "`let` and `const` are introduced in ES6 while `var` has existed since ES1."
            ],
            "answer": 2
          },
          {
            "question": "What will be the output of this coercion example?\n\n```js\nconsole.log(true + false);\n```",
            "options": [
              "\"truefalse\"",
              "1",
              "NaN",
              "TypeError"
            ],
            "answer": 1
          },
          {
            "question": "Which of the following best describes the behavior of the `this` keyword in JavaScript?",
            "options": [
              "It always refers to the global object.",
              "It refers to the object that the function was called on.",
              "It always refers to the parent functionâ€™s scope.",
              "`this` behaves the same in both arrow functions and normal functions."
            ],
            "answer": 1
          },
          {
            "question": "Which of the following cases will result in implicit type coercion?",
            "options": [
              "`'5' + 3`",
              "`Number('5') + 3`",
              "`Boolean(0)`",
              "`parseInt('42')`"
            ],
            "answer": 0
          },
          {
            "question": "What will be the output of the following code?\n\n```js\nfunction test() {\n  console.log(x);\n  let x = 5;\n}\ntest();\n```",
            "options": [
              "5",
              "undefined",
              "ReferenceError",
              "TypeError"
            ],
            "answer": 2
          },
          {
            "question": "Which of the following best explains why JavaScript is a dynamically typed language?",
            "options": [
              "Variable types are explicitly declared before use.",
              "Types of variables can change at runtime.",
              "JavaScript does not have types.",
              "JavaScript uses static type checking."
            ],
            "answer": 1
          },
          {
            "question": "What will be logged in the following case?\n\n```js\nlet x = 42;\ndelete x;\nconsole.log(x);\n```",
            "options": [
              "42",
              "undefined",
              "ReferenceError",
              "TypeError"
            ],
            "answer": 0
          },
          {
            "question": "What will be the result of this operation?\n\n```js\nconsole.log([] == ![]);\n```",
            "options": [
              "true",
              "false",
              "TypeError",
              "ReferenceError"
            ],
            "answer": 0
          },
          {
            "question": "Which of the following is NOT true about the prototype chain?",
            "options": [
              "An object can directly modify its prototype using `Object.setPrototypeOf()`.",
              "A prototype itself can have a prototype.",
              "All objects inherit directly from `Object.prototype`.",
              "Function prototypes can have their own properties."
            ],
            "answer": 2
          },
          {
            "question": "What will be logged in this scenario?\n\n```js\nconst obj = {\n  a: 10,\n  print: () => console.log(this.a)\n};\nobj.print();\n```",
            "options": [
              "10",
              "undefined",
              "ReferenceError",
              "TypeError"
            ],
            "answer": 1
          },
          {
            "question": "Which of the following correctly describes variable hoisting?",
            "options": [
              "Only `var` declarations are hoisted, not `let` or `const`.",
              "All variables and function declarations are hoisted.",
              "Hoisting means variables are assigned values before execution.",
              "Arrow functions are hoisted the same way as regular functions."
            ],
            "answer": 0
          },
          {
            "question": "What will be the output of the following snippet?\n\n```js\nconsole.log(typeof NaN);\n```",
            "options": [
              "\"undefined\"",
              "\"number\"",
              "\"NaN\"",
              "\"null\""
            ],
            "answer": 1
          },
          {
            "question": "Which statement about closures is FALSE?",
            "options": [
              "Closures allow a function to retain access to its outer scope variables.",
              "Closures can help create private variables in JavaScript.",
              "Closures cannot be created inside loops.",
              "Closures are frequently used in event handling and callbacks."
            ],
            "answer": 2
          },
          {
            "question": "What will be logged in the following case?\n\n```js\nconsole.log(0.1 + 0.2 === 0.3);\n```",
            "options": [
              "true",
              "false",
              "TypeError",
              "ReferenceError"
            ],
            "answer": 1
          },
          {
            "question": "How does `Object.create()` work in JavaScript?",
            "options": [
              "It copies all properties from one object to another.",
              "It creates a new object with the specified prototype.",
              "It creates a deep copy of an object.",
              "It creates an object without any prototype."
            ],
            "answer": 1
          },
          {
            "question": "What is the difference between `null` and `undefined` in JavaScript?",
            "options": [
              "`null` is explicitly assigned, while `undefined` means a variable is uninitialized.",
              "`undefined` is a falsy value, but `null` is truthy.",
              "`null` is a primitive type, but `undefined` is not.",
              "There is no difference; they are interchangeable."
            ],
            "answer": 0
          },
          {
            "question": "What will be the result of the following code?\n\n```js\nconsole.log(+'10' + 5);\n```",
            "options": [
              "\"105\"",
              "15",
              "NaN",
              "TypeError"
            ],
            "answer": 1
          },
          {
            "question": "How does JavaScript handle floating point arithmetic?",
            "options": [
              "It uses 64-bit floating point numbers but may cause precision issues.",
              "It ensures accurate precision by default.",
              "JavaScript converts all numbers to integers before performing arithmetic.",
              "Floating point operations always produce whole numbers."
            ],
            "answer": 0
          },
          {
            "question": "What is the result of `typeof function(){} === 'function'`?",
            "options": [
              "true",
              "false",
              "TypeError",
              "ReferenceError"
            ],
            "answer": 0
          },
          {
            "question": "Which best explains why `typeof null` is `'object'` in JavaScript?",
            "options": [
              "It is a historical bug in JavaScript.",
              "Null objects have properties, making them part of the object type.",
              "It was changed in ES6 for compatibility reasons.",
              "Null is treated as an empty object in JavaScript."
            ],
            "answer": 0
          },
          {
            "question": "What will be the output of this coercion case?\n\n```js\nconsole.log('5' - 2);\n```",
            "options": [
              "\"3\"",
              "3",
              "\"52\"",
              "NaN"
            ],
            "answer": 1
          },
          {
            "question": "What happens when you compare two objects in JavaScript using `==`?",
            "options": [
              "It checks if the objects have the same properties and values.",
              "It compares object references, returning true only if they reference the same object.",
              "It performs deep comparison automatically.",
              "Objects are always equal when compared with `==`."
            ],
            "answer": 1
          },
          {
            "question": "What will be logged in this scenario?\n\n```js\nconsole.log(true == '1');\n```",
            "options": [
              "true",
              "false",
              "TypeError",
              "ReferenceError"
            ],
            "answer": 0
          },
          {
            "question": "Which of the following best describes function expressions in JavaScript?",
            "options": [
              "Function expressions are always hoisted.",
              "Function expressions can be named or anonymous and are assigned to variables.",
              "Function expressions cannot be used inside other functions.",
              "Function expressions are only allowed in ES6."
            ],
            "answer": 1
          }
        ]
      }
      ,
      {
        "category": "JavaScript Functions",
        "questions": [
          {
            "question": "What will be logged by the following code?\n\n```js\nfunction outer() {\n  let count = 0;\n  return function inner() {\n    count++;\n    console.log(count);\n  };\n}\nconst fn = outer();\nfn();\nfn();\n```",
            "options": [
              "1, 2",
              "0, 1",
              "NaN, NaN",
              "ReferenceError"
            ],
            "answer": 0
          },
          {
            "question": "Which statement about higher-order functions is TRUE?",
            "options": [
              "Higher-order functions are only available in ES6 and later.",
              "A function is higher-order if it takes another function as an argument or returns a function.",
              "Arrow functions cannot be used as higher-order functions.",
              "Higher-order functions must always return another function."
            ],
            "answer": 1
          },
          {
            "question": "What will be the output of the following IIFE?\n\n```js\n(function() {\n  var x = 10;\n  console.log(x);\n})();\nconsole.log(x);\n```",
            "options": [
              "10, undefined",
              "10, 10",
              "ReferenceError, ReferenceError",
              "10, ReferenceError"
            ],
            "answer": 3
          },
          {
            "question": "How do closures help in JavaScript?",
            "options": [
              "They store values in local storage.",
              "They allow functions to retain access to variables from their lexical scope even after execution.",
              "They prevent functions from being hoisted.",
              "They allow JavaScript to run multiple threads simultaneously."
            ],
            "answer": 1
          },
          {
            "question": "What will be logged in the following example?\n\n```js\nfunction makeCounter() {\n  let count = 0;\n  return {\n    increment: function() { count++; },\n    getCount: function() { console.log(count); }\n  };\n}\nconst counter = makeCounter();\ncounter.increment();\ncounter.getCount();\n```",
            "options": [
              "0",
              "1",
              "undefined",
              "ReferenceError"
            ],
            "answer": 1
          },
          {
            "question": "Which of the following statements is FALSE about function expressions?",
            "options": [
              "Function expressions can be assigned to variables.",
              "Function expressions are always hoisted to the top of their scope.",
              "Function expressions can be anonymous or named.",
              "Function expressions can be passed as arguments to other functions."
            ],
            "answer": 1
          },
          {
            "question": "What will be the output of the following callback function?\n\n```js\nfunction greet(name, callback) {\n  console.log(\"Hello, \" + name);\n  callback();\n}\ngreet(\"Alice\", function() { console.log(\"Goodbye!\"); });\n```",
            "options": [
              "\"Hello, Alice\" followed by \"Goodbye!\"",
              "\"Goodbye!\" followed by \"Hello, Alice\"",
              "Error: Callback functions must be named",
              "Nothing, because the callback is not executed"
            ],
            "answer": 0
          },
          {
            "question": "Which of the following best describes an Immediately Invoked Function Expression (IIFE)?",
            "options": [
              "A function that is called before being defined.",
              "A function that executes immediately after being defined.",
              "A function that does not return anything.",
              "A function that cannot be assigned to a variable."
            ],
            "answer": 1
          },
          {
            "question": "What is the result of the following function execution?\n\n```js\nconst add = function(a) {\n  return function(b) {\n    return a + b;\n  };\n};\nconsole.log(add(5)(3));\n```",
            "options": [
              "8",
              "undefined",
              "NaN",
              "ReferenceError"
            ],
            "answer": 0
          },
          {
            "question": "What is a key difference between function declarations and function expressions?",
            "options": [
              "Function declarations are hoisted, while function expressions are not.",
              "Function expressions cannot have parameters.",
              "Function expressions cannot be used inside closures.",
              "Function declarations cannot be named."
            ],
            "answer": 0
          },
          {
            "question": "What happens if you call a function that does not return anything?\n\n```js\nfunction example() {}\nconsole.log(example());\n```",
            "options": [
              "\"undefined\"",
              "null",
              "ReferenceError",
              "TypeError"
            ],
            "answer": 0
          },
          {
            "question": "Which statement about `this` in arrow functions is correct?",
            "options": [
              "Arrow functions have their own `this` binding.",
              "Arrow functions inherit `this` from their surrounding lexical scope.",
              "Arrow functions dynamically determine `this` based on how they are called.",
              "Arrow functions cannot be used as methods."
            ],
            "answer": 1
          },
          {
            "question": "What will be the output of this function scope example?\n\n```js\nvar a = 10;\nfunction example() {\n  console.log(a);\n  var a = 20;\n}\nexample();\n```",
            "options": [
              "10",
              "20",
              "undefined",
              "ReferenceError"
            ],
            "answer": 2
          },
          {
            "question": "Which of the following statements about function scope is TRUE?",
            "options": [
              "Variables declared inside a function are accessible outside that function.",
              "Function scope means variables declared inside a function are only accessible within that function.",
              "Function scope applies only to `let` and `const`.",
              "Function scope prevents closures from forming."
            ],
            "answer": 1
          },
          {
            "question": "What will be logged by this IIFE?\n\n```js\n(function() {\n  var message = \"Hello\";\n  console.log(message);\n})();\nconsole.log(message);\n```",
            "options": [
              "\"Hello\", followed by \"Hello\"",
              "\"Hello\", followed by ReferenceError",
              "\"Hello\", followed by undefined",
              "ReferenceError, followed by ReferenceError"
            ],
            "answer": 1
          },
          {
            "question": "What will be the output of this function call?\n\n```js\nfunction example(a = 5, b = a * 2) {\n  console.log(a, b);\n}\nexample(3);\n```",
            "options": [
              "3, 6",
              "5, 10",
              "3, 10",
              "ReferenceError"
            ],
            "answer": 0
          },
          {
            "question": "Which of the following best describes a function returning another function?",
            "options": [
              "Currying",
              "Callback pattern",
              "Event delegation",
              "Promise chaining"
            ],
            "answer": 0
          }
        ]
      },
      {
        "category": "JavaScript Objects & Prototypes",
        "questions": [
          {
            "question": "What will be the output of the following code?\n\n```js\nconst obj = {a: 10};\nconst prototype = {b: 20};\nObject.setPrototypeOf(obj, prototype);\nconsole.log(obj.b);\n```",
            "options": [
              "10",
              "20",
              "undefined",
              "ReferenceError"
            ],
            "answer": 1
          },
          {
            "question": "What happens when you try to delete a non-configurable property in an object?",
            "options": [
              "It throws an error.",
              "It silently fails and returns `true`.",
              "The property remains unchanged.",
              "The property is deleted and an error is thrown."
            ],
            "answer": 2
          },
          {
            "question": "Which of the following will return an empty object in JavaScript?",
            "options": [
              "`new Object()`",
              "`Object.create(null)`",
              "`Object.prototype`",
              "`Object() {}`"
            ],
            "answer": 1
          },
          {
            "question": "Which of the following methods allows you to set the prototype of an object in JavaScript?",
            "options": [
              "`Object.getPrototypeOf()`",
              "`Object.setPrototypeOf()`",
              "`Object.createPrototype()`",
              "`Object.inheritPrototype()`"
            ],
            "answer": 1
          },
          {
            "question": "What will be the output of the following code?\n\n```js\nconst obj1 = {a: 10};\nconst obj2 = {a: 20};\nObject.setPrototypeOf(obj2, obj1);\nconsole.log(obj2.a);\n```",
            "options": [
              "10",
              "20",
              "undefined",
              "ReferenceError"
            ],
            "answer": 0
          },
          {
            "question": "Which of the following methods will return an array of property names (keys) of an object?",
            "options": [
              "`Object.keys()`",
              "`Object.getOwnPropertyNames()`",
              "`Object.values()`",
              "`Object.entries()`"
            ],
            "answer": 0
          },
          {
            "question": "What will be the result of the following code?\n\n```js\nconst obj = {a: 10};\nconsole.log(Object.prototype.hasOwnProperty.call(obj, 'a'));\n```",
            "options": [
              "true",
              "false",
              "undefined",
              "TypeError"
            ],
            "answer": 0
          },
          {
            "question": "Which of the following statements is TRUE regarding JavaScript prototypes?",
            "options": [
              "All JavaScript objects have a prototype chain.",
              "Prototype chain only exists for objects created using constructor functions.",
              "Prototypes can be deleted after object creation.",
              "You cannot modify the prototype of an object once it is created."
            ],
            "answer": 0
          },
          {
            "question": "How can you create an object that inherits from another object in JavaScript?",
            "options": [
              "Use `Object.inherit()`",
              "Use `Object.create()`",
              "Use `new Object()`",
              "Use `Object.prototype`"
            ],
            "answer": 1
          },
          {
            "question": "What will be the result of this code?\n\n```js\nconst obj = {a: 10};\nconst obj2 = Object.create(obj);\nobj2.b = 20;\nconsole.log(obj2.b);\nconsole.log(obj2.a);\n```",
            "options": [
              "undefined, 10",
              "20, 10",
              "20, undefined",
              "undefined, undefined"
            ],
            "answer": 1
          },
          {
            "question": "What happens if you modify a property in an object that is part of its prototype chain?",
            "options": [
              "The property is modified in the prototype.",
              "The property is added to the object.",
              "The property is modified in the original prototype.",
              "The object throws an error."
            ],
            "answer": 1
          },
          {
            "question": "Which of the following statements is TRUE about the `hasOwnProperty` method?",
            "options": [
              "`hasOwnProperty` returns `true` only for properties directly on the object, not from the prototype chain.",
              "`hasOwnProperty` checks for the property in the prototype chain.",
              "`hasOwnProperty` is a static method of `Object`.",
              "`hasOwnProperty` can be overridden by objects."
            ],
            "answer": 0
          },
          {
            "question": "What will be the result of the following code?\n\n```js\nfunction MyConstructor() {}\nMyConstructor.prototype = {a: 10};\nconst obj = new MyConstructor();\nconsole.log(obj.a);\n```",
            "options": [
              "10",
              "undefined",
              "ReferenceError",
              "TypeError"
            ],
            "answer": 0
          },
          {
            "question": "What will the following code output?\n\n```js\nconst obj = {a: 10};\nObject.defineProperty(obj, 'b', {\n  value: 20,\n  writable: false,\n  configurable: false\n});\nobj.b = 30;\nconsole.log(obj.b);\n```",
            "options": [
              "20",
              "30",
              "undefined",
              "ReferenceError"
            ],
            "answer": 0
          },
          {
            "question": "What will be the result of the following code?\n\n```js\nconst obj = {a: 10};\ndelete obj.a;\nconsole.log(obj.a);\n```",
            "options": [
              "undefined",
              "10",
              "NaN",
              "ReferenceError"
            ],
            "answer": 0
          }
        ]
      }
,
{
    "category": "Asynchronous JavaScript",
    "questions": [
      {
        "question": "What will be the output of the following code?\n\n```js\nconsole.log('Start');\nsetTimeout(() => console.log('Timeout'), 0);\nPromise.resolve().then(() => console.log('Promise'));\nconsole.log('End');\n```",
        "options": [
          "'Start', 'End', 'Promise', 'Timeout'",
          "'Start', 'Promise', 'End', 'Timeout'",
          "'Start', 'Timeout', 'Promise', 'End'",
          "'Start', 'End', 'Timeout', 'Promise'"
        ],
        "answer": 1
      },
      {
        "question": "Which statement is TRUE about the behavior of the JavaScript event loop?",
        "options": [
          "The event loop always executes synchronous code first before any asynchronous code.",
          "The event loop processes all microtasks after the execution of each synchronous task and before executing macrotasks.",
          "The event loop processes macrotasks and microtasks concurrently.",
          "The event loop prioritizes macrotasks over microtasks."
        ],
        "answer": 1
      },
      {
        "question": "Which of the following will print 'Done' first?\n\n```js\nasync function test() {\n  console.log('Start');\n  await new Promise(resolve => setTimeout(resolve, 0));\n  console.log('End');\n}\ntest();\nconsole.log('Done');\n```",
        "options": [
          "'Start', 'Done', 'End'",
          "'Start', 'End', 'Done'",
          "'Done', 'Start', 'End'",
          "'End', 'Start', 'Done'"
        ],
        "answer": 2
      },
      {
        "question": "What will the following code output?\n\n```js\nconst promise = new Promise((resolve, reject) => {\n  resolve('Success');\n});\n\npromise.then((result) => {\n  console.log(result);\n}).catch((error) => {\n  console.log(error);\n});\n```",
        "options": [
          "Success",
          "undefined",
          "Error",
          "TypeError"
        ],
        "answer": 0
      },
      {
        "question": "What will be the output of the following code?\n\n```js\nasync function test() {\n  return 'Hello';\n}\nconsole.log(test());\n```",
        "options": [
          "'Hello'",
          "Promise { 'Hello' }",
          "undefined",
          "Error"
        ],
        "answer": 1
      },
      {
        "question": "Which of the following statements about Promises is FALSE?",
        "options": [
          "A Promise is always asynchronous.",
          "A Promise can only be in one state at a time.",
          "A Promise can resolve or reject only once.",
          "A Promise that is already resolved or rejected will not trigger its `.then()` or `.catch()` callbacks."
        ],
        "answer": 0
      },
      {
        "question": "Which of the following will log '100' first?\n\n```js\nconsole.log('Start');\nsetTimeout(() => console.log(100), 0);\nPromise.resolve().then(() => console.log(50));\nconsole.log('End');\n```",
        "options": [
          "'Start', 'End', '50', '100'",
          "'Start', 'End', '100', '50'",
          "'Start', '50', 'End', '100'",
          "'Start', '100', 'End', '50'"
        ],
        "answer": 0
      },
      {
        "question": "What will the following code output?\n\n```js\nasync function delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\ndelay(1000).then(() => console.log('Done')); // 1 second delay\nconsole.log('Start');\n```",
        "options": [
          "'Start', 'Done'",
          "'Done', 'Start'",
          "'Start', undefined, 'Done'",
          "'Done', 'Start'"
        ],
        "answer": 0
      },
      {
        "question": "What is the difference between `setTimeout` and `Promise` in terms of event loop behavior?",
        "options": [
          "Both `setTimeout` and `Promise` use the same queue for their tasks.",
          "`setTimeout` always runs its task before a `Promise`.",
          "`Promise` tasks are executed before `setTimeout` tasks, even if `setTimeout` has a 0ms delay.",
          "`setTimeout` can only be used with a delay, while `Promise` doesn't require one."
        ],
        "answer": 2
      },
      {
        "question": "What will the following code log?\n\n```js\nsetTimeout(() => { console.log(1); }, 0);\nPromise.resolve().then(() => { console.log(2); });\nconsole.log(3);\n```",
        "options": [
          "3, 1, 2",
          "3, 2, 1",
          "1, 3, 2",
          "2, 1, 3"
        ],
        "answer": 1
      },
      {
        "question": "What will be logged by the following code?\n\n```js\nfunction asyncTest() {\n  console.log('First');\n  setTimeout(() => console.log('Second'), 0);\n  console.log('Third');\n}\nasyncTest();\n```",
        "options": [
          "'First', 'Third', 'Second'",
          "'First', 'Second', 'Third'",
          "'First', 'Third', 'First'",
          "'Third', 'First', 'Second'"
        ],
        "answer": 0
      },
      {
        "question": "What will be the output of the following code?\n\n```js\nconst task = async () => { return 'Success'; };\nconst result = task();\nconsole.log(result);\n```",
        "options": [
          "'Success'",
          "Promise { 'Success' }",
          "undefined",
          "Error"
        ],
        "answer": 1
      },
      {
        "question": "What happens if you don't handle a rejected Promise in JavaScript?",
        "options": [
          "The JavaScript engine will automatically recover from the rejection.",
          "It will throw an error and terminate the program.",
          "The rejection will be silently ignored unless caught.",
          "The rejection will cause the event loop to stop processing further tasks."
        ],
        "answer": 2
      },
      {
        "question": "What is the behavior of `await` when used with a non-Promise value?",
        "options": [
          "It immediately resolves the non-Promise value.",
          "It waits for the non-Promise value to be resolved.",
          "It causes an error.",
          "It returns the Promise-wrapped value."
        ],
        "answer": 0
      }
    ]
  }
,
{
    "category": "JavaScript in the Browser",
    "questions": [
      {
        "question": "What will be the output of the following code?\n\n```js\nconst div = document.createElement('div');\ndiv.textContent = 'Hello';\ndocument.body.appendChild(div);\nconsole.log(div.textContent);\n```",
        "options": [
          "'Hello'",
          "undefined",
          "'div'",
          "null"
        ],
        "answer": 0
      },
      {
        "question": "Which of the following methods can be used to prevent the default action of an event in JavaScript?",
        "options": [
          "`event.preventDefault()`",
          "`event.stopPropagation()`",
          "`event.cancelDefault()`",
          "`event.blockAction()`"
        ],
        "answer": 0
      },
      {
        "question": "What is the purpose of `event.target` in event handling?",
        "options": [
          "It refers to the element that triggered the event.",
          "It refers to the element that is currently being handled by the event listener.",
          "It refers to the global object in the browser.",
          "It refers to the last element in the DOM."
        ],
        "answer": 0
      },
      {
        "question": "Which of the following methods is used to create a new HTML element in JavaScript?",
        "options": [
          "`document.createElement()`",
          "`document.addElement()`",
          "`document.create()`",
          "`document.insertElement()`"
        ],
        "answer": 0
      },
      {
        "question": "What will the following code log?\n\n```js\nconst button = document.querySelector('button');\nbutton.addEventListener('click', (e) => { console.log(e.target); });\nbutton.click();\n```",
        "options": [
          "The button element",
          "undefined",
          "Error",
          "null"
        ],
        "answer": 0
      },
      {
        "question": "Which of the following is the correct way to access a CSS property of an element using JavaScript?",
        "options": [
          "`element.style.property`",
          "`element.css.property`",
          "`element.getProperty('property')`",
          "`element.setStyle('property')`"
        ],
        "answer": 0
      },
      {
        "question": "How can you prevent an event from propagating to its parent elements in the DOM?",
        "options": [
          "`event.stopPropagation()`",
          "`event.preventDefault()`",
          "`event.stopImmediatePropagation()`",
          "`event.cancelPropagation()`"
        ],
        "answer": 0
      },
      {
        "question": "What will the following code output?\n\n```js\nwindow.addEventListener('resize', () => { console.log('Resized'); });\nwindow.innerWidth = 500;\nwindow.dispatchEvent(new Event('resize'));\n```",
        "options": [
          "'Resized'",
          "'resize' event",
          "undefined",
          "Error"
        ],
        "answer": 0
      },
      {
        "question": "Which of the following is NOT a valid method of interacting with Local Storage in JavaScript?",
        "options": [
          "`localStorage.setItem()`",
          "`localStorage.getItem()`",
          "`localStorage.removeItem()`",
          "`localStorage.clearItem()`"
        ],
        "answer": 3
      },
      {
        "question": "Which of the following is true about the `fetch` API in JavaScript?",
        "options": [
          "`fetch` returns a Promise that resolves to the response of the request.",
          "`fetch` directly modifies the DOM with the response.",
          "`fetch` requires a callback function to handle the response.",
          "`fetch` is used to create an XMLHttpRequest object."
        ],
        "answer": 0
      },
      {
        "question": "What will be the result of the following code?\n\n```js\nconsole.log(localStorage.getItem('name')); // null\nlocalStorage.setItem('name', 'John');\nconsole.log(localStorage.getItem('name'));\n```",
        "options": [
          "null, 'John'",
          "'John', null",
          "null, null",
          "'John', 'John'"
        ],
        "answer": 0
      },
      {
        "question": "What will the following code output?\n\n```js\nconst div = document.querySelector('div');\ndiv.innerHTML = '<span>Test</span>'; \ndocument.body.appendChild(div);\nconsole.log(div.innerHTML);\n```",
        "options": [
          "'<span>Test</span>'",
          "'Test'",
          "'div'",
          "'<div><span>Test</span></div>'"
        ],
        "answer": 0
      },
      {
        "question": "How would you target a button element with the class 'btn' using JavaScript?",
        "options": [
          "`document.querySelector('.btn')`",
          "`document.getElementById('btn')`",
          "`document.getElementsByClassName('btn')`",
          "`document.getElementByClass('btn')`"
        ],
        "answer": 0
      },
      {
        "question": "Which method would you use to change the text of an existing element in the DOM?",
        "options": [
          "`element.textContent = 'New Text'`",
          "`element.setText('New Text')`",
          "`element.innerText = 'New Text'`",
          "`element.changeText('New Text')`"
        ],
        "answer": 0
      },
      {
        "question": "Which of the following methods is used to remove an event listener in JavaScript?",
        "options": [
          "`element.removeEventListener()`",
          "`element.deleteEventListener()`",
          "`element.remove()`",
          "`element.stopEventListener()`"
        ],
        "answer": 0
      }
    ]
  }
,
{
    "category": "Functional Programming & Meta-Programming in JavaScript",
    "questions": [
      {
        "question": "What is the output of the following code?\n\n```js\nconst obj = { a: 1, b: 2 };\nconst newObj = Object.freeze({ ...obj });\nnewObj.a = 3;\nconsole.log(newObj.a);\n```",
        "options": [
          "1",
          "3",
          "undefined",
          "Error"
        ],
        "answer": 0
      },
      {
        "question": "Which of the following is the most significant feature of a pure function?",
        "options": [
          "It does not modify any external state or variables.",
          "It always performs the same calculation regardless of inputs.",
          "It has no side effects.",
          "All of the above."
        ],
        "answer": 3
      },
      {
        "question": "What is the purpose of the `Object.freeze()` method in JavaScript?",
        "options": [
          "It creates a deep clone of the object.",
          "It prevents modifications to the objectâ€™s properties and values.",
          "It converts the object to a JSON string.",
          "It converts the object to a shallow copy."
        ],
        "answer": 1
      },
      {
        "question": "What is the result of the following function call?\n\n```js\nconst sum = (a, b) => a + b;\nconst multiply = (a, b) => a * b;\nconst compose = (f, g) => (x, y) => f(g(x, y));\nconst result = compose(sum, multiply)(2, 3);\nconsole.log(result);\n```",
        "options": [
          "5",
          "6",
          "30",
          "12"
        ],
        "answer": 0
      },
      {
        "question": "Which of the following methods creates a new object without modifying the original one?",
        "options": [
          "`Object.assign()`",
          "`Object.create()`",
          "`Object.freeze()`",
          "`Object.entries()`"
        ],
        "answer": 0
      },
      {
        "question": "What is the primary purpose of the `Proxy` object in JavaScript?",
        "options": [
          "To define custom behavior for fundamental operations on objects.",
          "To convert an object into a new data type.",
          "To allow deep cloning of objects.",
          "To provide a mechanism for inheritance."
        ],
        "answer": 0
      },
      {
        "question": "Which of the following is an example of a higher-order function?",
        "options": [
          "`Array.map()`",
          "`Math.max()`",
          "`Date.now()`",
          "`console.log()`"
        ],
        "answer": 0
      },
      {
        "question": "What is the output of the following code?\n\n```js\nconst arr = [1, 2, 3];\nconst result = arr.map((x) => x * 2).filter((x) => x > 3);\nconsole.log(result);\n```",
        "options": [
          "[2, 4, 6]",
          "[4, 6]",
          "[6]",
          "[2, 6]"
        ],
        "answer": 1
      },
      {
        "question": "Which of the following statements about immutability is TRUE?",
        "options": [
          "Immutability means that data cannot be changed after it is created.",
          "Immutability allows data to be mutated safely.",
          "Immutability applies only to primitive values, not objects.",
          "Immutability is not important in functional programming."
        ],
        "answer": 0
      },
      {
        "question": "What will the following code output?\n\n```js\nconst obj = { a: 1, b: 2 };\nconst handler = {\n  get: (target, prop) => prop in target ? target[prop] : 0\n};\nconst proxyObj = new Proxy(obj, handler);\nconsole.log(proxyObj.c);\n```",
        "options": [
          "undefined",
          "0",
          "Error",
          "null"
        ],
        "answer": 1
      },
      {
        "question": "Which of the following methods can be used to prevent changes to an object's properties?",
        "options": [
          "`Object.seal()`",
          "`Object.freeze()`",
          "`Object.preventExtensions()`",
          "`All of the above`"
        ],
        "answer": 1
      },
      {
        "question": "What will be the result of the following code?\n\n```js\nconst obj = { a: 1, b: 2 };\nObject.freeze(obj);\nobj.a = 3;\nconsole.log(obj.a);\n```",
        "options": [
          "1",
          "3",
          "undefined",
          "Error"
        ],
        "answer": 0
      },
      {
        "question": "What is the effect of calling `Object.create()` in JavaScript?",
        "options": [
          "It creates a shallow copy of an object.",
          "It creates a new object that inherits from the given prototype.",
          "It creates a deep copy of an object.",
          "It adds new properties to an existing object."
        ],
        "answer": 1
      },
      {
        "question": "Which of the following statements best describes a pure function?",
        "options": [
          "A function that always returns the same result for the same arguments.",
          "A function that modifies the global state.",
          "A function that uses external variables.",
          "A function that never returns a value."
        ],
        "answer": 0
      },
      {
        "question": "Which of the following is true about the `Reflect` API in JavaScript?",
        "options": [
          "It provides methods for intercepting and manipulating object operations.",
          "It allows defining custom setters and getters.",
          "It can be used for working with arrays.",
          "It is mainly used for manipulating DOM elements."
        ],
        "answer": 0
      },
      {
        "question": "What does the following code snippet do?\n\n```js\nconst handler = {\n  get: function(target, prop) {\n    return prop in target ? target[prop] : `Property ${prop} not found`;\n  }\n};\nconst proxy = new Proxy({}, handler);\nconsole.log(proxy.name);\n```",
        "options": [
          "'Property name not found'",
          "undefined",
          "null",
          "Error"
        ],
        "answer": 0
      },
      {
        "question": "Which of the following is NOT an advantage of functional programming?",
        "options": [
          "Functions can be composed to create more complex operations.",
          "State is mutable, leading to fewer bugs.",
          "Pure functions are predictable and easier to test.",
          "Functions can be used as arguments and returned as values."
        ],
        "answer": 1
      },
      {
        "question": "What does the following code log?\n\n```js\nconst add = (x, y) => x + y;\nconst multiply = (x, y) => x * y;\nconst compose = (f, g) => (x, y) => f(g(x, y));\nconst result = compose(add, multiply)(2, 3);\nconsole.log(result);\n```",
        "options": [
          "5",
          "6",
          "30",
          "12"
        ],
        "answer": 0
      }
    ]
  }
  
      
    ]
  }
        
      
    